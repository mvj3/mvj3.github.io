<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | 世界的审美！]]></title>
  <link href="http://mvj3.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://mvj3.github.io/"/>
  <updated>2013-12-23T11:47:41+08:00</updated>
  <id>http://mvj3.github.io/</id>
  <author>
    <name><![CDATA[mvj3]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby同时启动另一个进程]]></title>
    <link href="http://mvj3.github.io/2013/02/25/start-another-process-in-ruby/"/>
    <updated>2013-02-25T14:33:51+08:00</updated>
    <id>http://mvj3.github.io/2013/02/25/start-another-process-in-ruby</id>
    <content type="html"><![CDATA[<p>比如自动启动faye服务器, from <a href="http://stackoverflow.com/questions/6430437/autorun-the-faye-server-when-i-start-the-rails-server">http://stackoverflow.com/questions/6430437/autorun-the-faye-server-when-i-start-the-rails-server</a></p>

<p><code>ruby
Thread.new do
  system("bundle exec rackup faye.ru -s thin -E production")
end
</code></p>

<p>如果是Rails/Rack，加入到项目根目录的config.ru，这样在执行console, rake, migration等其他操作时就不用启动这个进程了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby声明默认是空数组的Hash]]></title>
    <link href="http://mvj3.github.io/2013/02/18/declare-a-Hash-which-default-value-is-blank-array-in-ruby/"/>
    <updated>2013-02-18T12:13:50+08:00</updated>
    <id>http://mvj3.github.io/2013/02/18/declare-a-Hash-which-default-value-is-blank-array-in-ruby</id>
    <content type="html"><![CDATA[<p>Ruby里声明一个新Hash的方法一般是</p>

<p><code>ruby
im_a_new_hash = {}
</code></p>

<p>如果给它设一个为0的默认值，可以
<code>ruby
im_a_new_hash.default = 0
</code>
变成一行语句就是
<code>ruby
im_a_new_hash = Hash.new 0
</code></p>

<p>但是这里注意，这里的0其实是个唯一对象，即是每一个默认值的object_id都是一样的，比如
<code>ruby
im_a_string_hash = Hash.new "string" # =&gt; {}
im_a_string_hash[3] # =&gt; "string"
im_a_string_hash[3].object_id # =&gt; 2168523080
im_a_string_hash[4].object_id # =&gt; 2168523080
</code>
可以看到取键3和4的默认值的object_id都是2168523080</p>

<p>Ruby里提供了new {|hash, key| block } → new_hash的方法, 因此声明一个默认是空数组的Hash的具体方法应该是
<code>ruby
im_a_default_array_hash = Hash.new {|hash, key| hash[key] = [] } # =&gt; {}
im_a_default_array_hash[99] # =&gt; []
im_a_default_array_hash[99].object_id # =&gt; 160533940
im_a_default_array_hash[99].object_id # =&gt; 160533940
im_a_default_array_hash[100].object_id # =&gt; 160571060
</code>
可以看到键99的值的object_id一直是160533940，而键100的值的object_id则是160571060</p>

<p>具体文档查看 <a href="http://www.ruby-doc.org/core-1.9.3/Hash.html#method-c-new">http://www.ruby-doc.org/core-1.9.3/Hash.html#method-c-new</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby的Dir.glob缓存BUG]]></title>
    <link href="http://mvj3.github.io/2013/02/18/Dir-glob-cache-bug-in-ruby/"/>
    <updated>2013-02-18T10:56:07+08:00</updated>
    <id>http://mvj3.github.io/2013/02/18/Dir-glob-cache-bug-in-ruby</id>
    <content type="html"><![CDATA[<p>Ruby的Dir.glob(&lsquo;/your/absolute/path/*&rsquo;)有缓存bug，新文件并不会返回，改成FileUtils.chdir后在Dir.glob(pattern)解决</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[个性域名正则表达式]]></title>
    <link href="http://mvj3.github.io/2013/01/23/individual-domain-regexp/"/>
    <updated>2013-01-23T16:35:34+08:00</updated>
    <id>http://mvj3.github.io/2013/01/23/individual-domain-regexp</id>
    <content type="html"><![CDATA[<p>老大提了个用单个正则表达式来匹配个性域名ID的需求，具体是：3-15个字符，可以用[a-z0-9_-]字符，必须用数字或者字母开头，且不能是纯数字</p>

<p>让我们来分步化解
对于，3-15个字符，可以用[a-z0-9_-]字符，稍微了解点正则表达式的同学马上就可以写出如下正则</p>

<p><code>ruby
/^[a-z0-9_\-]{3,15}$/i
</code></p>

<p>让我们来再加一个条件，必须用数字或者字母开头
<code>ruby
/^[0-9a-z][a-z0-9_\-]{2,14}$/i
</code></p>

<p>最后一个条件是，且不能是纯数字。</p>

<p>最初我大概的想到是用 或(|) 来做，一个是数字开头，另一个是字母开头，剩余的是否纯数字在后面判断。但这剩余里还是会遇到判断在哪个位置里已经出现了字母的问题。所以这里就需要正则表达式里非匹配获取的功能了。</p>

<p>维基百科里给出的是 (?=pattern) ，它表示 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符「(|)」来组合一个模式的各个部分是很有用。例如「industr(?:y|ies)」就是一个比「industry|industries」更简略的表达式。具体见 <a href="http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">http://zh.wikipedia.org/wiki/正则表达式</a></p>

<p>stackoverflow里有更通俗的例子 <a href="http://stackoverflow.com/questions/1559751/regex-to-make-sure-that-the-string-contains-at-least-one-lower-case-char-upper">http://stackoverflow.com/questions/1559751/regex-to-make-sure-that-the-string-contains-at-least-one-lower-case-char-upper</a>
<code>text
^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*(_|[^\w])).+$
A short explanation:
^                  // the start of the string
(?=.*[a-z])        // use positive look ahead to see if at least one lower case letter exists
(?=.*[A-Z])        // use positive look ahead to see if at least one upper case letter exists
(?=.*\d)           // use positive look ahead to see if at least one digit exists
(?=.*[_\W])        // use positive look ahead to see if at least one underscore or non-word character exists
.+                 // gobble up the entire string
$                  // the end of the string
</code></p>

<p>这样我们就在 <code>/^[0-9a-z][a-z0-9_-]{2,14}$/i</code> 里再加上个 <code>(?=.*[a-z_\-])</code> 就可以匹配不是纯数字了
```ruby
@regexp = /^(?=.*[a-z<em>-])[0-9a-z][a-z0-9</em>-]{2,14}$/i</p>

<p>puts &ldquo;合法测试&rdquo;
%w[c11213311 mvj3 123mmmmm iceskysl 3_3].each do |str|
  puts &ldquo;#{str}   =>   #{str.match(@regexp)}&rdquo;
end</p>

<p>puts &ldquo;\n&rdquo;</p>

<p>puts &ldquo;非法测试&rdquo;
%w[123 12345 mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm _ssssss 你好].each do |str|
  puts &ldquo;#{str}   =>   #{str.match(@regexp) || &lsquo;没有匹配&rsquo;}&rdquo;
end
```</p>

<p>测试结果如下
```text
合法测试
c11213311   =>   c11213311
mvj3   =>   mvj3
123mmmmm   =>   123mmmmm
iceskysl   =>   iceskysl
3_3   =>   3_3</p>

<p>非法测试
123   =>   没有匹配
12345   =>   没有匹配
mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm   =>   没有匹配
_ssssss   =>   没有匹配
你好   =>   没有匹配
```</p>

<h2>Ruby-China上的讨论 <a href="http://ruby-china.org/topics/8383">http://ruby-china.org/topics/8383</a></h2>

<p>我景仰的大牛 @luikore 给出了易读版</p>

<p><code>ruby
/\A
  (?=.*[a-z_\-])    # 不能全是数字
  [0-9a-z]          # 必须用数字或者字母开头
  [a-z0-9_\-]{2,14} # 3-15个字符，可以用[a-z0-9_\-]字符
\z/xi
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trie和Hash访问字符串性能比较]]></title>
    <link href="http://mvj3.github.io/2012/12/21/compare-the-access-speed-between-trie-and-hash/"/>
    <updated>2012-12-21T10:12:13+08:00</updated>
    <id>http://mvj3.github.io/2012/12/21/compare-the-access-speed-between-trie-and-hash</id>
    <content type="html"><![CDATA[<h2>摘自wikipedia的trie词条</h2>

<p>在计算机科学中，trie，又称前缀树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>

<h2>摘自wikipedia的Hash词条</h2>

<p>散列函数（或散列算法，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p>

<h2>用同样的字符串数组来各自构造一万以上元素的Hash和Trie</h2>

<p>```ruby</p>

<h1>gem dependencies: algorithms, nokogiri</h1>

<p>%w[benchmark algorithms open-uri nokogiri].map &amp;method(:require)</p>

<p>string_array_for_insert = Nokogiri(open(&lsquo;<a href="http://www.douban.com">http://www.douban.com</a>&rsquo;).read).text.split(&ldquo;\n&rdquo;).map(&amp;:strip).uniq
string_array_for_insert = (string_array_for_insert*100).map {|i| i.split(//).shuffle.join }
hash = string_array_for_insert.inject({}) {|h, i| h[i] = rand(100000); h }
trie = Containers::Trie.new; string_array_for_insert.each {|i| trie[i] = rand(100000) }</p>

<p>Benchmark.bm(8) do |x|
  x.report(&ldquo;hash:&rdquo;) { string_array_for_insert.each {|i| hash[i] } }
  x.report(&ldquo;trie:&rdquo;) { string_array_for_insert.each {|i| trie[i] } }
end</p>

<p>=begin</p>

<pre><code>           user     system      total        real
</code></pre>

<p>hash:      0.010000   0.000000   0.010000 (  0.007240)
trie:      0.490000   0.010000   0.500000 (  0.503553)
=end
```</p>

<p>由以上判断，Hash算法的O(1)远比Trie的O(m)快 (m为键的最大长度)，如非类搜索提示的字符串匹配等应用，一般的键值对采用Hash可以保证最快查找单个元素。</p>
]]></content>
  </entry>
  
</feed>
