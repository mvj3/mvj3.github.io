<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Search | 世界的审美！]]></title>
  <link href="http://mvj3.github.io/blog/categories/search/atom.xml" rel="self"/>
  <link href="http://mvj3.github.io/"/>
  <updated>2013-07-08T20:51:32+08:00</updated>
  <id>http://mvj3.github.io/</id>
  <author>
    <name><![CDATA[mvj3]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给xunsearch提供一对多的不重复的数据列表]]></title>
    <link href="http://mvj3.github.io/2013/03/25/provide-Xunsearch-no-duplicated-one-to-many-data-list/"/>
    <updated>2013-03-25T14:07:30+08:00</updated>
    <id>http://mvj3.github.io/2013/03/25/provide-Xunsearch-no-duplicated-one-to-many-data-list</id>
    <content type="html"><![CDATA[<h2>问题概述</h2>

<p>同事采用的xunsearch搜索引擎在搜索一对多表时遇到了重复内容的问题，问题在通过SQL语句来生成的单表有因为一对多而导致的重复信息。简单google下，发现要用group_concat把两个表要用到的文本字段来把每个都合成到一行记录里，但是这样复杂的SQL估计只有大拿才能写的出来。</p>

<h2>解决方案</h2>

<p>于是我想到之前做的thinking-sphinx是支持一对多联合查询的，那就看看thinking-sphinx是如何来生成SQL的。</p>

<p>配置thinking-sphinx，这个参考官网。</p>

<p>code_gists对应多个code_documents，给搜索模块配置索引结构</p>

<p>```ruby
class CodeGist &lt; ActiveRecord::Base
  define_index do</p>

<pre><code>indexes documents.filename, :as =&gt; :content
indexes documents.content, :as =&gt; :content
indexes :description, :as =&gt; :content
indexes :author, :as =&gt; :content

where "(code_gists.deleted_at IS NULL AND code_documents.deleted_at IS NULL)"
</code></pre>

<p>  end
end
```</p>

<p>运行bundle exec rake ts:config后，在config目录就有了config/production.sphinx.conf文件，察看source区块的sql_query为</p>

<p><code>sql
SELECT SQL_NO_CACHE `code_gists`.`id` * CAST(3 AS SIGNED) + 0 AS `id` , GROUP_CONCAT(DISTINCT IFNULL(`code_documents`.`filename`, '0') SEPARATOR ' ') AS `content`, GROUP_CONCAT(DISTINCT IFNULL(`code_documents`.`content`, '0') SEPARATOR ' ') AS `content`, `code_gists`.`description` AS `content`, `code_gists`.`id` AS `sphinx_internal_id`, 0 AS `sphinx_deleted`, 1875287073 AS `class_crc`, IFNULL(`code_gists`.`author`, '') AS `author` FROM `code_gists` LEFT OUTER JOIN `code_documents` ON `code_documents`.`gist_id` = `code_gists`.`id` WHERE (`code_gists`.`id` &gt;= $start AND `code_gists`.`id` &lt;= $end AND (code_gists.deleted_at IS NULL AND code_documents.deleted_at IS NULL)) GROUP BY `code_gists`.`id` ORDER BY NULL;
</code></p>

<p>稍微整理后，变成</p>

<p><code>``sql
SELECT SQL_NO_CACHE</code>code_gists<code>.</code>id`,</p>

<pre><code>                GROUP_CONCAT(DISTINCT IFNULL(`code_documents`.`filename`, '0') SEPARATOR ' ') AS `content`,
                GROUP_CONCAT(DISTINCT IFNULL(`code_documents`.`content`, '0') SEPARATOR ' ') AS `content`,
                `code_gists`.`description` AS `content`,
                IFNULL(`code_gists`.`author`, '') AS `content`
</code></pre>

<p>FROM <code>code_gists</code>
LEFT OUTER JOIN <code>code_documents</code> ON <code>code_documents</code>.<code>gist_id</code> = <code>code_gists</code>.<code>id</code>
WHERE (code_gists.deleted_at IS NULL AND code_documents.deleted_at IS NULL)
GROUP BY <code>code_gists</code>.<code>id</code>;
```</p>

<p>运行一下，就返回了不重复的数据列表了</p>
]]></content>
  </entry>
  
</feed>
