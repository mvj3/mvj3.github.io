<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | 世界的审美！]]></title>
  <link href="http://mvj3.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://mvj3.github.io/"/>
  <updated>2013-07-09T21:00:50+08:00</updated>
  <id>http://mvj3.github.io/</id>
  <author>
    <name><![CDATA[mvj3]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails常见配置问题]]></title>
    <link href="http://mvj3.github.io/2013/03/06/rails-general-configuration-problems/"/>
    <updated>2013-03-06T10:42:41+08:00</updated>
    <id>http://mvj3.github.io/2013/03/06/rails-general-configuration-problems</id>
    <content type="html"><![CDATA[<h2>提示已经安装的gem不在Gemfile里</h2>

<p>最近有时遇到明明已经安装了rake，但是却提示我说有些gem没有在Gemfile里引用。比如：
Could not find rake-0.9.2.2 in any of the sources
Run &lsquo;bundle install&rsquo; to install missing gems.</p>

<p>我所使用的Ruby版本管理环境是rvm，查看下rvm info，发现ruby路径和gem管理路径不一致，因此rvm reload一下就解决了该问题。</p>

<p>rvm不一致的问题还需要查下，推测可能是开启多个SHELL，导致设置不一致～</p>

<h2>assets没有编译</h2>

<p>需要显示指定路径，在config/environments/production.rb里加入
<code>ruby
config.assets.precompile += %w[*js *css]
</code></p>

<h2>development模式下刷新后静态资源不变</h2>

<p>删除public/assets目录下的缓存文件，这样就走动态请求了。</p>

<h2>修复rvm info里ruby版本不一致bug</h2>

<p>在/etc/profile里加一行rvm reload</p>

<h2>修复gem,irb等命令里老是提示ree某个版本的environment不存在</h2>

<p>修改该命令里的ruby环境路径到自己指定的版本</p>

<h2>修复默写外部css引用图片等静态资源不以/assets开头</h2>

<p>把资源及其路径直接拷到/public目录下</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord兼容非正规数据库表名和表字段设计的多对多，一对多关系]]></title>
    <link href="http://mvj3.github.io/2013/01/24/define-many-to-many-and-one-to-many-associations-for-informal-database-table-and-field-design-in-activerecord/"/>
    <updated>2013-01-24T16:07:41+08:00</updated>
    <id>http://mvj3.github.io/2013/01/24/define-many-to-many-and-one-to-many-associations-for-informal-database-table-and-field-design-in-activerecord</id>
    <content type="html"><![CDATA[<p>Rails里的多对多关系声明极其简单，一句 <code>has_and_belongs_to_many :projects</code> 就可表示当前表通过一个中间表来拥有多个projects，唯一的约定就是复数的表名和_id后缀的外键。</p>

<p>但是如果你接手的数据库是在别的不同约定的语言框架里设计的，这样去套用Rails的 <code>has_and_belongs_to_many</code> 就炕爹了，你得一个一个去声明每一个选项，以下就是本人惨痛的经历，其他人看了就不用重蹈覆辙了。</p>

<p>参考：<a href="http://guides.rubyonrails.org/association_basics.html">http://guides.rubyonrails.org/association_basics.html</a> ，和本地的Rails rdoc文档</p>

<p>需求是查出一个用户收藏的所有代码。</p>

<p> 先来看下表结构。用户，收藏，代码三个表结构主要部分如下：
<code>``sql
CREATE TABLE</code>common_member<code>(
 </code>uid<code>mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (</code>uid`),
) ENGINE=MyISAM AUTO_INCREMENT=802058 DEFAULT CHARSET=utf8;</p>

<p>CREATE TABLE <code>common_user_favorite</code> (
  <code>itemid</code> int(11) NOT NULL,
  <code>uid</code> int(11) NOT NULL,
  <code>model</code> enum(&lsquo;blog&rsquo;,&lsquo;code&rsquo;,&lsquo;news&rsquo;,&lsquo;book&rsquo;) NOT NULL,
  <code>create_time</code> int(11) NOT NULL,
  <code>is_delete</code> tinyint(1) NOT NULL DEFAULT &lsquo;0&rsquo;
) ENGINE=InnoDB DEFAULT CHARSET=utf8;</p>

<p>CREATE TABLE <code>code_gists</code> (
  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,
  <code>user_id</code> int(11) DEFAULT NULL,
  <code>created_at</code> datetime NOT NULL,
  <code>updated_at</code> datetime NOT NULL,
  <code>deleted_at</code> tinyint(1) DEFAULT NULL,
  PRIMARY KEY (<code>id</code>),
  KEY <code>index_code_gists_on_deleted_at_and_user_id_and_updated_at</code> (<code>deleted_at</code>,<code>user_id</code>,<code>updated_at</code>)
) ENGINE=InnoDB AUTO_INCREMENT=149 DEFAULT CHARSET=utf8;
```</p>

<p>我们接下来的代码逻辑就是查找出目标用户，通过收藏表，来找出该用户的所有代码。</p>

<p>先声明三个model如下：
<code>ruby
class CommonMember &lt; ActiveRecord::Base
  self.table_name = :common_member
end
class CommonUserFavorite &lt; ActiveRecord::Base
  self.table_name = :common_user_favorite
end
class CodeGist &lt; ActiveRecord::Base
end
</code></p>

<p>接着声明三个model之间的关系
<code>ruby
CommonUserFavoriteConditions = "`common_user_favorite`.`is_delete` = 0 AND `common_user_favorite`.`model` = 'code'"
class CommonMember &lt; ActiveRecord::Base
  has_many :fav_gists, :through =&gt; :favs, :order =&gt; "`common_user_favorite`.`create_time` DESC", :source =&gt; :gist
  has_many :favs, :class_name =&gt; CommonUserFavorite, :foreign_key =&gt; :uid, :conditions =&gt; CommonUserFavoriteConditions
end
class CommonUserFavorite &lt; ActiveRecord::Base
  belongs_to :gist, :class_name =&gt; CodeGist, :foreign_key =&gt; :itemid
end
class CodeGist &lt; ActiveRecord::Base
  has_many :favs, :class_name =&gt; CommonUserFavorite, :foreign_key =&gt; :itemid, :conditions =&gt; CommonUserFavoriteConditions
end
</code></p>

<p>以下是解释</p>

<p>先声明收藏表(CommonUserFavorite) <code>belongs_to</code> 代码表(CodeGist)，指定 收藏表(CommonUserFavorite)  的外键是:itemid，关联的代码表(CodeGist)的主键是:id。示例如：
<code>CommonUserFavorite.where(:model =&gt; 'code').first.gist</code>
<code>``sql
SELECT</code>common_user_favorite`.*</p>

<pre><code>    FROM `common_user_favorite`
    WHERE `common_user_favorite`.`model` = 'code'
    LIMIT 1;
</code></pre>

<p>SELECT <code>code_gists</code>.*</p>

<pre><code>    FROM `code_gists`
    WHERE `code_gists`.`id` = 43 AND (`code_gists`.`deleted_at` IS NULL)
    LIMIT 1;
</code></pre>

<p>```</p>

<p>再声明代码表(CodeGist) <code>has_many</code> 收藏表(CommonUserFavorite) ，指定 收藏表(CommonUserFavorite)  的外键是 :itemid，且查询条件是 <code>:conditions =&gt; ["common_user_favorite.model = 'code'"]</code> 。示例如： <code>CodeGist.last.favs</code>
<code>``sql
SELECT</code>code_gists`.*</p>

<pre><code>    FROM `code_gists`
    WHERE (`code_gists`.`deleted_at` IS NULL)
    ORDER BY `code_gists`.`id` DESC
    LIMIT 1;
</code></pre>

<p>SELECT <code>common_user_favorite</code>.*</p>

<pre><code>    FROM `common_user_favorite`
    WHERE `common_user_favorite`.`itemid` = 107
            AND (`common_user_favorite`.`is_delete` = 0
            AND `common_user_favorite`.`model` = 'code');
</code></pre>

<p>```</p>

<p>最后声明是用户表(CommonMember)对代码表(CodeGist)的has_many 是通过 用户表(CommonMember)对收藏表(CommonUserFavorite)的has_many 和 收藏表(CommonUserFavorite)对代码表(CodeGist)的belongs_to 共同实现的，这两个声明关系分别表述为  <code>:through =&gt; :favs</code> 和  <code>:source =&gt; :gist</code>。各自的示例如：</p>

<p><code>cm = CommonMember.where(:uid =&gt; 470700).first</code>
<code>``sql
SELECT</code>common_member`.*</p>

<pre><code>    FROM `common_member`
    WHERE `common_member`.`uid` = 470700
    LIMIT 1;
</code></pre>

<p>```</p>

<p><code>cm.fav_gists</code>
<code>``sql
SELECT</code>code_gists`.*</p>

<pre><code>    FROM `code_gists`
    INNER JOIN `common_user_favorite`
          ON `code_gists`.`id` = `common_user_favorite`.`itemid`
    WHERE `common_user_favorite`.`uid` = 470700
          AND (`code_gists`.`deleted_at` IS NULL)
          AND (`common_user_favorite`.`is_delete` = 0
          AND `common_user_favorite`.`model` = 'code')
    ORDER BY `common_user_favorite`.`create_time` DESC;
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails解决JSON数据跨域问题 Access Control Allow Origin not allowed by]]></title>
    <link href="http://mvj3.github.io/2013/01/15/fix-json-cross-domain/"/>
    <updated>2013-01-15T15:09:03+08:00</updated>
    <id>http://mvj3.github.io/2013/01/15/fix-json-cross-domain</id>
    <content type="html"><![CDATA[<p>XMLHttpRequest请求在不同域名下会出现"Access Control Allow Origin not allowed by"消息，即使是不同子域名，或根域名和子域名，也会出现这种情况。</p>

<p>详情见 <a href="https://developer.mozilla.org/en/http_access_control">https://developer.mozilla.org/en/http_access_control</a></p>

<p>rails控制器的方法加下以下声明即可
<code>ruby
response.header['Access-Control-Allow-Origin'] = '*'
response.header['Content-Type'] = 'text/javascript'
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Route配置多个点的参数]]></title>
    <link href="http://mvj3.github.io/2012/12/19/rails-routes-match-multiple-dots/"/>
    <updated>2012-12-19T12:49:00+08:00</updated>
    <id>http://mvj3.github.io/2012/12/19/rails-routes-match-multiple-dots</id>
    <content type="html"><![CDATA[<p>代码分享里要对动态的资源文件做路由匹配，设置路由为</p>

<p><code>ruby
match "/code/:gist_id/:tree_sha/blob/:blob_sha/:filename" =&gt; "code#file", :via =&gt; :get
</code></p>

<p>但是它却无法对像 /code/18/9877da148810c9d8bb5691772fda5488302259b6/blob/9084c88ef62c2566c315d3c4ff6e157146f4bfb4/测试点号.Android<em>开发中使用</em>SQLite_数据库.pdf  包含多个点号的URL做匹配，抛出了ActionController::RoutingError (No route matches 的异常。</p>

<p>google到一个解决方案 <a href="http://x3ro.de/rails-3-routing-parameters-dots/">http://x3ro.de/rails-3-routing-parameters-dots/</a> , 使用constraints参数去对特点的URL做正则匹配。比如 <code>match "/foo/:search", :constraints =&gt; { :search =&gt; /[^\/]*/ }</code>  会对URL最后非 / 字符串做全部匹配。</p>

<p>Rails官方文档见 <a href="http://edgeguides.rubyonrails.org/routing.html#segment-constraints">http://edgeguides.rubyonrails.org/routing.html#segment-constraints</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二分查找定位Rails文本日志]]></title>
    <link href="http://mvj3.github.io/2011/09/17/use-binary-search-to-seek-a-position-in-rails-logs/"/>
    <updated>2011-09-17T15:21:54+08:00</updated>
    <id>http://mvj3.github.io/2011/09/17/use-binary-search-to-seek-a-position-in-rails-logs</id>
    <content type="html"><![CDATA[<p>对网站作统计分析时，经常需要对各种文本日志定时进行解析抽取数据，因此有必要确定上次结束解析的位置。<a href="http://github.com/mvj3/logpos">logpos</a>使用<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分法</a>进行查找，具体用法如：
<code>ruby
pos = Logpos.seek_pos_before log_path, (RptVerbPathParams.desc(:time).first.try(:time) || Time.at(0))
</code>
logpos是以Rails默认的日志格式来解析的，但是也可以自己定义一个时间解析器：
<code>ruby
lg = Logpos.new
lg.time_parser = proc do |line|
  line.match(/^Started/) &amp;&amp; TIME_PARSER_CLASS.parse(line.split(/for [0-9\.]* at /)[-1])
end
pos = lg.seek_pos_before log_path, time
</code>
Logpos接受的time_parser要求是一个Proc，返回是一个Time实例或nil，以便之后的比较。</p>

<p>我这边测试一个4G多的正常的Rails日志文件，对不同的时间点做测试，日志记录时间范围内的一般在10毫秒以下，范围外的在80毫秒以下。</p>
]]></content>
  </entry>
  
</feed>
